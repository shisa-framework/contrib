// generated by "charlatan -output=./vaultlogicalreader_charlatan.go logicalReader".  DO NOT EDIT.

package env

import "reflect"

import vault "github.com/hashicorp/vault/api"

// logicalReaderReadInvocation represents a single call of FakelogicalReader.Read
type logicalReaderReadInvocation struct {
	Parameters struct {
		Path string
	}
	Results struct {
		Ident1 *vault.Secret
		Ident2 error
	}
}

// NewlogicalReaderReadInvocation creates a new instance of logicalReaderReadInvocation
func NewlogicalReaderReadInvocation(path string, ident1 *vault.Secret, ident2 error) *logicalReaderReadInvocation {
	invocation := new(logicalReaderReadInvocation)

	invocation.Parameters.Path = path

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// logicalReaderTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type logicalReaderTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakelogicalReader is a mock implementation of logicalReader for testing.
Use it in your tests as in this example:

	package example

	func TestWithlogicalReader(t *testing.T) {
		f := &env.FakelogicalReader{
			ReadHook: func(path string) (ident1 *vault.Secret, ident2 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeRead ...
		f.AssertReadCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeRead.
*/
type FakelogicalReader struct {
	ReadHook func(string) (*vault.Secret, error)

	ReadCalls []*logicalReaderReadInvocation
}

// NewFakelogicalReaderDefaultPanic returns an instance of FakelogicalReader with all hooks configured to panic
func NewFakelogicalReaderDefaultPanic() *FakelogicalReader {
	return &FakelogicalReader{
		ReadHook: func(string) (ident1 *vault.Secret, ident2 error) {
			panic("Unexpected call to logicalReader.Read")
		},
	}
}

// NewFakelogicalReaderDefaultFatal returns an instance of FakelogicalReader with all hooks configured to call t.Fatal
func NewFakelogicalReaderDefaultFatal(t logicalReaderTestingT) *FakelogicalReader {
	return &FakelogicalReader{
		ReadHook: func(string) (ident1 *vault.Secret, ident2 error) {
			t.Fatal("Unexpected call to logicalReader.Read")
			return
		},
	}
}

// NewFakelogicalReaderDefaultError returns an instance of FakelogicalReader with all hooks configured to call t.Error
func NewFakelogicalReaderDefaultError(t logicalReaderTestingT) *FakelogicalReader {
	return &FakelogicalReader{
		ReadHook: func(string) (ident1 *vault.Secret, ident2 error) {
			t.Error("Unexpected call to logicalReader.Read")
			return
		},
	}
}

func (f *FakelogicalReader) Reset() {
	f.ReadCalls = []*logicalReaderReadInvocation{}
}

func (_f1 *FakelogicalReader) Read(path string) (ident1 *vault.Secret, ident2 error) {
	if _f1.ReadHook == nil {
		panic("logicalReader.Read() called but FakelogicalReader.ReadHook is nil")
	}

	invocation := new(logicalReaderReadInvocation)
	_f1.ReadCalls = append(_f1.ReadCalls, invocation)

	invocation.Parameters.Path = path

	ident1, ident2 = _f1.ReadHook(path)

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return
}

// SetReadStub configures logicalReader.Read to always return the given values
func (_f2 *FakelogicalReader) SetReadStub(ident1 *vault.Secret, ident2 error) {
	_f2.ReadHook = func(string) (*vault.Secret, error) {
		return ident1, ident2
	}
}

// SetReadInvocation configures logicalReader.Read to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f3 *FakelogicalReader) SetReadInvocation(calls_f4 []*logicalReaderReadInvocation, fallback_f5 func() (*vault.Secret, error)) {
	_f3.ReadHook = func(path string) (ident1 *vault.Secret, ident2 error) {
		for _, call := range calls_f4 {
			if reflect.DeepEqual(call.Parameters.Path, path) {
				ident1 = call.Results.Ident1
				ident2 = call.Results.Ident2

				return
			}
		}

		return fallback_f5()
	}
}

// ReadCalled returns true if FakelogicalReader.Read was called
func (f *FakelogicalReader) ReadCalled() bool {
	return len(f.ReadCalls) != 0
}

// AssertReadCalled calls t.Error if FakelogicalReader.Read was not called
func (f *FakelogicalReader) AssertReadCalled(t logicalReaderTestingT) {
	t.Helper()
	if len(f.ReadCalls) == 0 {
		t.Error("FakelogicalReader.Read not called, expected at least one")
	}
}

// ReadNotCalled returns true if FakelogicalReader.Read was not called
func (f *FakelogicalReader) ReadNotCalled() bool {
	return len(f.ReadCalls) == 0
}

// AssertReadNotCalled calls t.Error if FakelogicalReader.Read was called
func (f *FakelogicalReader) AssertReadNotCalled(t logicalReaderTestingT) {
	t.Helper()
	if len(f.ReadCalls) != 0 {
		t.Error("FakelogicalReader.Read called, expected none")
	}
}

// ReadCalledOnce returns true if FakelogicalReader.Read was called exactly once
func (f *FakelogicalReader) ReadCalledOnce() bool {
	return len(f.ReadCalls) == 1
}

// AssertReadCalledOnce calls t.Error if FakelogicalReader.Read was not called exactly once
func (f *FakelogicalReader) AssertReadCalledOnce(t logicalReaderTestingT) {
	t.Helper()
	if len(f.ReadCalls) != 1 {
		t.Errorf("FakelogicalReader.Read called %d times, expected 1", len(f.ReadCalls))
	}
}

// ReadCalledN returns true if FakelogicalReader.Read was called at least n times
func (f *FakelogicalReader) ReadCalledN(n int) bool {
	return len(f.ReadCalls) >= n
}

// AssertReadCalledN calls t.Error if FakelogicalReader.Read was called less than n times
func (f *FakelogicalReader) AssertReadCalledN(t logicalReaderTestingT, n int) {
	t.Helper()
	if len(f.ReadCalls) < n {
		t.Errorf("FakelogicalReader.Read called %d times, expected >= %d", len(f.ReadCalls), n)
	}
}

// ReadCalledWith returns true if FakelogicalReader.Read was called with the given values
func (_f6 *FakelogicalReader) ReadCalledWith(path string) (found bool) {
	for _, call := range _f6.ReadCalls {
		if reflect.DeepEqual(call.Parameters.Path, path) {
			found = true
			break
		}
	}

	return
}

// AssertReadCalledWith calls t.Error if FakelogicalReader.Read was not called with the given values
func (_f7 *FakelogicalReader) AssertReadCalledWith(t logicalReaderTestingT, path string) {
	t.Helper()
	var found bool
	for _, call := range _f7.ReadCalls {
		if reflect.DeepEqual(call.Parameters.Path, path) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakelogicalReader.Read not called with expected parameters")
	}
}

// ReadCalledOnceWith returns true if FakelogicalReader.Read was called exactly once with the given values
func (_f8 *FakelogicalReader) ReadCalledOnceWith(path string) bool {
	var count int
	for _, call := range _f8.ReadCalls {
		if reflect.DeepEqual(call.Parameters.Path, path) {
			count++
		}
	}

	return count == 1
}

// AssertReadCalledOnceWith calls t.Error if FakelogicalReader.Read was not called exactly once with the given values
func (_f9 *FakelogicalReader) AssertReadCalledOnceWith(t logicalReaderTestingT, path string) {
	t.Helper()
	var count int
	for _, call := range _f9.ReadCalls {
		if reflect.DeepEqual(call.Parameters.Path, path) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakelogicalReader.Read called %d times with expected parameters, expected one", count)
	}
}

// ReadResultsForCall returns the result values for the first call to FakelogicalReader.Read with the given values
func (_f10 *FakelogicalReader) ReadResultsForCall(path string) (ident1 *vault.Secret, ident2 error, found bool) {
	for _, call := range _f10.ReadCalls {
		if reflect.DeepEqual(call.Parameters.Path, path) {
			ident1 = call.Results.Ident1
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}
